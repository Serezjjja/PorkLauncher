import { useState, useEffect, useCallback } from "react";
import {
  DownloadAndLaunch,
  DownloadAndLaunchWithServer,
  GetNick,
  SetNick as SetNickBackend,
  GetInstanceInfo,
  GetReleaseVersions,
  GetPreReleaseVersions,
  GetLauncherVersion,
  Update,
  SetLocalGameVersion,
  UpdateInstanceBranch,
  GetServers,
  Login,
  Logout,
  GetCurrentUser,
} from "../../wailsjs/go/app/App";
import { EventsOn } from "../../wailsjs/runtime/runtime";
import { useTranslation } from "../i18n";
import { model, service } from "../../wailsjs/go/models";

// Re-export server type
export type ServerWithFullUrls = service.ServerWithUrls;

// Auth types (will be generated by Wails after build)
export interface CurrentUserResponse {
  loggedIn: boolean;
  username?: string;
  roles?: string[];
}

export interface AuthResponse {
  success: boolean;
  username?: string;
  roles?: string[];
  error?: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export type ReleaseType = "release" | "pre-release";

export const useLauncher = () => {
  const { t } = useTranslation();

  const [username, setUsername] = useState<string>("Player");
  const [currentVersion, setCurrentVersion] = useState<string>("0");
  const [selectedBranch, setSelectedBranch] = useState<ReleaseType>("release");
  
  // Store the latest version number for display
  const [latestVersionNumber, setLatestVersionNumber] = useState<number | null>(null);
  
  // Only "auto" and "latest" are supported
  // - "auto": Always stays on latest with auto-updates
  // - "latest": Static install of current latest version
  const availableVersions = [
    { value: "auto", label: "auto" },
    { value: "latest", label: latestVersionNumber ? `latest (v${latestVersionNumber})` : "latest" }
  ];

  const [launcherVersion, setLauncherVersion] = useState<string>("0.0.0");
  const [isEditingUsername, setIsEditingUsername] = useState<boolean>(false);
  const [isLoadingVersions, setIsLoadingVersions] = useState<boolean>(true);
  
  // Servers state
  const [servers, setServers] = useState<service.ServerWithUrls[]>([]);
  const [isLoadingServers, setIsLoadingServers] = useState(true);

  const [progress, setProgress] = useState<number>(0);
  const [status, setStatus] = useState<string>(t.control.status.readyToPlay);
  const [isDownloading, setIsDownloading] = useState<boolean>(false);

  const [downloadDetails, setDownloadDetails] = useState({
    currentFile: "",
    speed: "",
    downloaded: 0,
    total: 0,
  });

  const [updateAsset, setUpdateAsset] = useState<any>(null);
  const [isUpdatingLauncher, setIsUpdatingLauncher] = useState<boolean>(false);
  const [updateStats, setUpdateStats] = useState({ d: 0, t: 0 });

  const [showDeleteModal, setShowDeleteModal] = useState<boolean>(false);
  const [showDiagnostics, setShowDiagnostics] = useState<boolean>(false);
  const [error, setError] = useState<any>(null);

  // Auth state
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [authUser, setAuthUser] = useState<CurrentUserResponse | null>(null);
  const [isAuthLoading, setIsAuthLoading] = useState<boolean>(false);
  const [authError, setAuthError] = useState<string | null>(null);
  const [showLoginModal, setShowLoginModal] = useState<boolean>(false);

  // Initial load: get instance info then fetch versions for saved branch
  useEffect(() => {
    const loadInstanceInfo = async () => {
      try {
        const info = await GetInstanceInfo() as model.InstanceModel;
        const savedBranch = (info.Branch || "pre-release") as ReleaseType;
        
        setCurrentVersion(String(info.BuildVersion || "0"));
        setSelectedBranch(savedBranch);
        
        // Fetch versions for the saved branch
        setIsLoadingVersions(true);
        const response = savedBranch === "release" 
          ? await GetReleaseVersions()
          : await GetPreReleaseVersions();
        
        if (response.error) {
          throw new Error(response.error);
        }
        
        // Get the latest version number for display
        if (response.versions && response.versions.length > 0) {
          const latest = Math.max(...response.versions);
          setLatestVersionNumber(latest);
        }
      } catch (err) {
        setError({
          type: "INSTANCE_LOAD_ERROR",
          message: "Failed to load instance configuration",
          technical: err instanceof Error ? err.message : String(err),
        });
      } finally {
        setIsLoadingVersions(false);
      }
    };

    loadInstanceInfo();
  }, []);

  useEffect(() => {
    GetNick().then((n: string) => {
      if (n) setUsername(n);
    });

    GetLauncherVersion().then((version: string) => {
      setLauncherVersion(version);
    });
    
    // Fetch latest version number for display
    const fetchLatestVersion = async () => {
      try {
        const response = await GetReleaseVersions();
        if (!response.error && response.versions && response.versions.length > 0) {
          // Get the highest version number
          const latest = Math.max(...response.versions);
          setLatestVersionNumber(latest);
        }
      } catch (err) {
        console.error("Failed to fetch latest version:", err);
      }
    };
    fetchLatestVersion();
    
    // Fetch servers
    GetServers().then((data: service.ServerWithUrls[]) => {
      setServers(data);
      setIsLoadingServers(false);
    }).catch(() => {
      setIsLoadingServers(false);
    });

    const offUpdateAvailable = EventsOn("update:available", (asset: any) => {
      setUpdateAsset(asset);
    });

    const offUpdateProgress = EventsOn(
      "update:progress",
      (d: number, t: number) => {
        const percentage = t > 0 ? (d / t) * 100 : 0;
        setProgress(percentage);
        setUpdateStats({ d, t });
      },
    );

    const offProgress = EventsOn("progress-update", (data: any) => {
      setProgress(data.progress ?? 0);
      setStatus(data.message ?? "");
      setDownloadDetails({
        currentFile: data.currentFile ?? "",
        speed: data.speed ?? "",
        downloaded: data.downloaded ?? 0,
        total: data.total ?? 0,
      });

      if (data.stage === "idle") {
        setIsDownloading(false);
        setProgress(0);
        setStatus(t.control.status.readyToPlay);
        setDownloadDetails({
          currentFile: "",
          speed: "",
          downloaded: 0,
          total: 0,
        });
      }
    });

    return () => {
      offUpdateAvailable();
      offUpdateProgress();
      offProgress();
    };
  }, [t.control.status.readyToPlay]);

  // Check auth on mount
  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      const user = await GetCurrentUser() as CurrentUserResponse;
      if (user.loggedIn) {
        setIsAuthenticated(true);
        setAuthUser(user);
        setUsername(user.username || "Player");
      } else {
        setIsAuthenticated(false);
        setAuthUser(null);
        setShowLoginModal(true);
      }
    } catch (err) {
      console.error("Auth check failed:", err);
      setIsAuthenticated(false);
      setAuthUser(null);
      setShowLoginModal(true);
    }
  };

  const handleLogin = async (email: string, password: string) => {
    setIsAuthLoading(true);
    setAuthError(null);

    try {
      const response = await Login({ email, password }) as AuthResponse;

      if (response.success) {
        setIsAuthenticated(true);
        setAuthUser({
          loggedIn: true,
          username: response.username,
          roles: response.roles,
        });
        setUsername(response.username || "Player");
        setShowLoginModal(false);
      } else {
        // Map error codes to user-friendly messages
        let errorMsg = response.error || "Login failed";
        if (errorMsg.includes("invalid_credentials")) {
          errorMsg = t.auth?.emailPlaceholder === "your@email.com" 
            ? "Invalid email or password" 
            : "Неверный email или пароль";
        } else if (errorMsg.includes("session_expired")) {
          errorMsg = t.auth?.emailPlaceholder === "your@email.com"
            ? "Session expired. Please login again."
            : "Сессия истекла. Войдите снова.";
        } else if (errorMsg.includes("no connection")) {
          errorMsg = t.auth?.emailPlaceholder === "your@email.com"
            ? "No connection to the website."
            : "Нет соединения с сайтом.";
        }
        setAuthError(errorMsg);
      }
    } catch (err) {
      setAuthError(String(err));
    } finally {
      setIsAuthLoading(false);
    }
  };

  const handleLogout = async () => {
    try {
      await Logout();
      setIsAuthenticated(false);
      setAuthUser(null);
      setUsername("Player");
      setShowLoginModal(true);
    } catch (err) {
      console.error("Logout failed:", err);
    }
  };

  const handlePlay = useCallback(async (serverIP?: string) => {
    // Check if user is authenticated
    if (!isAuthenticated) {
      setShowLoginModal(true);
      return;
    }

    // Check if user has an allowed role (player, Участник, Member)
    const allowedRoles = ["player", "Участник", "Member", "member"];
    const hasAllowedRole = authUser?.roles?.some(role => allowedRoles.includes(role));
    if (!hasAllowedRole) {
      setError({
        type: "AUTH_ERROR",
        message: t.auth?.noAccess || "No access to game",
        technical: t.auth?.checkAccount || "Check your account on the website",
      });
      return;
    }

    setIsDownloading(true);
    try {
      let response;
      if (serverIP) {
        response = await DownloadAndLaunchWithServer(username, serverIP);
      } else {
        response = await DownloadAndLaunch(username);
      }

      if (!response.success) {
        throw new Error(response.error || "Unknown error");
      }
    } catch (err) {
      setIsDownloading(false);
      setError({
        type: "LAUNCH_ERROR",
        message: "Failed to start game",
        technical: String(err),
      });
    }
  }, [username, currentVersion, selectedBranch, isAuthenticated, authUser, t]);

  const handleUpdateLauncher = async () => {
    setIsUpdatingLauncher(true);
    setProgress(0);
    setUpdateStats({ d: 0, t: 0 });
    try {
      await Update();
    } catch (err) {
      setError({
        type: "UPDATE_ERROR",
        message: "Failed to update launcher",
        technical: err instanceof Error ? err.message : String(err),
        timestamp: new Date().toISOString(),
      });
      setIsUpdatingLauncher(false);
    }
  };

  const setNick = useCallback((val: string) => {
    SetNickBackend(val, "default");
    setUsername(val);
  }, []);

  const setLocalGameVersion = useCallback(async (version: string) => {
    setCurrentVersion(version);
    
    try {
      await SetLocalGameVersion(version, "default"); 
    } catch (err) {
      setError({ 
        type: "CONFIG_ERROR", 
        message: "Failed to save version", 
        technical: String(err) 
      });
    }
  }, [setError]);

  const handleBranchChange = useCallback(async (branch: ReleaseType) => {
    try {
      // 1. Save to backend FIRST (this must complete)
      await UpdateInstanceBranch(branch);
      
      // 2. Update UI state
      setSelectedBranch(branch);
      
      // 3. Fetch versions for the new branch
      setIsLoadingVersions(true);
      const response = branch === "release" 
        ? await GetReleaseVersions()
        : await GetPreReleaseVersions();
      
      if (response.error) {
        throw new Error(response.error);
      }
      
      // Update latest version number when switching branches
      if (response.versions && response.versions.length > 0) {
        const latest = Math.max(...response.versions);
        setLatestVersionNumber(latest);
      }
    } catch (err) {
      setError({ 
        type: "CONFIG_ERROR", 
        message: "Failed to save branch", 
        technical: String(err) 
      });
    } finally {
      setIsLoadingVersions(false);
    }
  }, [setError]);

  return {
    username,
    currentVersion,
    selectedBranch,
    availableVersions,
    isLoadingVersions,
    launcherVersion,
    isEditingUsername,
    setIsEditingUsername,
    progress,
    status,
    isDownloading,
    downloadDetails,
    updateAsset,
    isUpdatingLauncher,
    updateStats,
    showDeleteModal,
    setShowDeleteModal,
    showDiagnostics,
    setShowDiagnostics,
    error,
    setError,
    handlePlay,
    handleUpdateLauncher,
    setNick,
    setLocalGameVersion,
    handleBranchChange,
    // Servers
    servers,
    isLoadingServers,
    // Auth
    isAuthenticated,
    authUser,
    isAuthLoading,
    authError,
    showLoginModal,
    setShowLoginModal,
    handleLogin,
    handleLogout,
    checkAuth,
  };
};